// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id         String   @id @default(uuid())
  email      String   @unique
  password   String
  name       String
  role       String   @default("USER") // USER or ADMIN
  lastActive DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  mustChangePassword Boolean @default(false)

  // AI Preferences
  jobTitle           String?
  department         String?
  technicalLevel     String?
  communicationStyle String?

  // Access Group relation
  accessGroupId String?
  accessGroup   AccessGroup? @relation(fields: [accessGroupId], references: [id], onDelete: SetNull)

  chatMessages  ChatMessage[]
  archivedChats ArchivedChat[]
  chatFolders   ChatFolder[]
  tokenUsages   TokenUsage[]
}

// Grupos de acesso com permissões por módulo
model AccessGroup {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  
  // Permissões de visualização por módulo
  canViewChat        Boolean @default(true)
  canViewMindMap     Boolean @default(true)
  canViewCatalog     Boolean @default(true)
  canViewUsers       Boolean @default(false)
  canViewMonitoring  Boolean @default(false)
  canViewDocuments   Boolean @default(false)
  canViewSettings    Boolean @default(false)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  users       User[]
}

// Registro de uso de tokens por solicitação
model TokenUsage {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Tokens consumidos
  inputTokens   Int
  outputTokens  Int
  totalTokens   Int
  
  // Contexto
  model         String   // ex: "gemini-1.5-pro", "llama-3.3-70b-versatile"
  requestType   String   @default("chat") // "chat", "embedding", etc.
  
  createdAt     DateTime @default(now())
  
  @@index([userId])
  @@index([createdAt])
}

// Configurações globais de custo por token
model TokenCostSettings {
  id               String   @id @default(uuid())
  
  // Custo por milhão de tokens (em BRL ou moeda configurada)
  inputCostPer1M   Float    @default(0)
  outputCostPer1M  Float    @default(0)
  
  currency         String   @default("BRL")
  
  updatedAt        DateTime @updatedAt
}

model Machine {
  id                String   @id @default(uuid())
  name              String
  category          String
  capacity          String
  model             String
  price             String
  maintenanceStatus String   @default("ok") // ok, attention, critical
  lastMaintenance   String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  specifications MachineSpecification[]
}

model MachineSpecification {
  id        String  @id @default(uuid())
  machineId String
  content   String
  machine   Machine @relation(fields: [machineId], references: [id], onDelete: Cascade)
}

model MindMap {
  id        String   @id @default(uuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  nodes MindMapNode[]
}

model MindMapNode {
  id        String  @id @default(uuid())
  mindMapId String
  label     String
  type      String  // machine, process, parameter
  x         Float
  y         Float
  mindMap   MindMap @relation(fields: [mindMapId], references: [id], onDelete: Cascade)

  // Connections from this node
  connectionsFrom MindMapConnection[] @relation("FromNode")
  // Connections to this node
  connectionsTo   MindMapConnection[] @relation("ToNode")
}

model MindMapConnection {
  id         String      @id @default(uuid())
  fromNodeId String
  toNodeId   String
  fromNode   MindMapNode @relation("FromNode", fields: [fromNodeId], references: [id], onDelete: Cascade)
  toNode     MindMapNode @relation("ToNode", fields: [toNodeId], references: [id], onDelete: Cascade)

  @@unique([fromNodeId, toNodeId])
}

model ChatMessage {
  id        String   @id @default(uuid())
  userId    String
  role      String   // user or assistant
  content   String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ArchivedChat {
  id            String   @id @default(uuid())
  userId        String
  title         String
  messagesCount Int
  messages      String   // JSON string of messages array
  createdAt     DateTime @default(now())
  archivedAt    DateTime @default(now())
  folderId      String?
  isPinned      Boolean  @default(false)

  user   User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder ChatFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)
}

model ChatFolder {
  id        String   @id @default(uuid())
  userId    String
  name      String
  isDefault Boolean  @default(false)
  order     Int      @default(0)
  createdAt DateTime @default(now())

  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  archivedChats ArchivedChat[]
}

model CatalogItem {
  id          String   @id @default(uuid())
  code        String   @unique
  name        String
  category    String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  documents Document[]
}

model DocumentFolder {
  id        String   @id @default(uuid())
  name      String
  order     Int      @default(0)
  createdAt DateTime @default(now())

  documents Document[]
}

model Document {
  id           String   @id @default(uuid())
  catalogId    String?  // Tornando opcional para documentos globais
  catalogItem  CatalogItem? @relation(fields: [catalogId], references: [id], onDelete: SetNull)
  
  // Folder organization
  folderId     String?
  folder       DocumentFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)

  // File information
  fileName     String
  fileType     String
  fileSize     Int
  filePath     String

  // Processing status
  indexed      Boolean  @default(false)
  processingProgress Int @default(0)
  processingError    String?

  // Controle de ativação
  isActive     Boolean  @default(true)  // Permite desativar sem deletar

  // Indexing metadata
  chunkCount   Int?
  totalTokens  Int?

  // Audit
  uploadedBy   String?
  uploadedAt   DateTime @default(now())
  indexedAt    DateTime?

  // Version control
  version      Int      @default(1)
  previousVersionId String?

  chunks       DocumentChunk[]
}

model DocumentChunk {
  id         String   @id @default(uuid())
  documentId String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  // Chunk content
  content    String
  chunkIndex Int

  // Embedding vector (stored as JSON array)
  embedding  String

  // Metadata
  metadata   String?  // JSON string for flexible metadata

  createdAt  DateTime @default(now())

  @@index([documentId])
}

